#! /usr/bin/env zsh

# 参考: https://stackoverflow.com/a/67916473
# 作用: 使用 Kitty 等普通终端模拟器 ssh 登录服务器并 cd 到对应目录后，直接使用
# - `vscode-remote .` 命令在本地 VS Code 新窗口中打开当前目录 或
# - `vscode-remote file_name` 命令在本地 VS Code 窗口中打开远程文件
# 原先 VS Code Server 的 code 命令只能先通过 VS Code 连接上远程服务器后才能生效

# 尝试 10 次的目的是为了增加找到一个有效 VS Code 远程窗口的机会
# - 用户可能同时打开了多个通过 SSH 连接的 VS Code 窗口。 每个窗口对应一个独立的 VS Code Server 实例和 IPC socket。
# - 用户可能关闭了一个 SSH 连接的 VS Code 窗口，但仍然保留着其他连接的窗口。 关闭窗口后，对应的 socket 文件可能仍然存在一段时间，或者文件系统上的时间戳可能没有立即更新。
# - (*oc[$i]N) 依赖于文件系统的时间戳来排序最近使用的 VS Code 实例。 但文件系统的时间戳更新可能存在延迟，或者因为某些操作（例如网络延迟、文件系统缓存）而不够精确。
# - 我们不能保证第一个（最近修改的）socket 一定对应于 当前 活跃的 VS Code 窗口。 它可能是一个已经关闭的窗口的残留。
# 因此，脚本通过循环尝试多个最近修改的 socket，来应对以下情况：
# - 过时的 socket: 最近修改的 socket 实际上对应于一个已经关闭的 VS Code 窗口。
# - 多个活跃窗口: 用户有多个活跃的 VS Code 窗口，但我们希望找到 任何 一个可用的窗口。
# - 时间戳不精确: 文件系统的时间戳排序可能不完全准确，导致最近使用的窗口没有排在第一位。
local max_retry=10

for i in {1..$max_retry}
do
    # 尝试找到第 i 个最近修改的 code 脚本，并将其路径赋值给 script 变量。
    # code 脚本位置可能有变化，使用 VS Code 连接后，`which code` 命令查看具体的位置
    local script=$(echo ~/.vscode-server/cli/servers/*/server/bin/remote-cli/code(*oc[$i]N))
    if [[ -z ${script} ]]
    then
        echo "VSCode remote script not found"
        exit 1
    fi
    local socket=$(echo /run/user/$UID/vscode-ipc-*.sock(=oc[$i]N))
    if [[ -z ${socket} ]]
    then
        echo "VSCode IPC socket not found"
        exit 1
    fi
    export VSCODE_IPC_HOOK_CLI=${socket}
    ${script} $@ > /dev/null 2>&1
    if [ "$?" -eq "0" ]; then
        exit 0
    fi
done

echo "Failed to find valid VS Code window"
